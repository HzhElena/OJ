#include <math.h>  
#include <iostream>  
using namespace std;  
  /* 公式法
  对p开k次方等价于求p的1/k次方，此时我们就可以用pow函数求解了： k = pow(p, 1.0/n)
   如果这题没有限制 底数k 是整数，就不可能通过公式投机取巧。 
    简单来说，如果要使用公式法，那么题目中所有运算都只能基于double类型进行（int会溢出）
   double的取值范围为10^(-307)~10^308，但小数精度只有前16位（可自行搜索double的精度丢失问题）. 
   也是就说，当我们用double存储p的时候, 它就已经开始出现误差, 其误差范围在10^(-15)的数量级左右.
  此时套用公式对p开n次方根，须知开方运算是不会扩大误差范围的，
  
       所以 n-sqrt(p) 的小数位误差范围依旧在10^(-15)的数量级以内， 
       又因为 k = n-sqrt(p) ，亦即计算所得的 n 的小数位误差范围也在10^(-15)的数量级以内, 
       显然这个误差级数仅会对n的小数部分存在影响，四舍五入后对整数部分是无影响的. 
       而题目已经限定了，n、k、p均是整数，因此使用公式法可以直接得到准确结果. 
 
       假若题目不存在整数限制，当n极大时，k会极小（无限迫近1，对小数精度极高）， 
       此时公式法则会因为精度问题而失效. 
       */
int main(void) {  
    double n , p;  
    while(cin >> n >> p) {  
        double tmp = pow(p, 1 / n); // p开n次方  
        int k = floor(tmp + 0.5);   // 四舍五入（+0.5后向下取整）  
        cout << k << endl;  
    }  
    return 0;  
}  
