# Summary of [POJ](http://poj.org/problemlist) solutions
Recording according to [problem category](https://blog.csdn.net/lyy289065406/article/details/78702485)
## 基本算法
### 枚举
#### 1. [1753 Flip Game](http://poj.org/problem?id=1753) / [Solution](https://github.com/HzhElena/OJ/blob/master/POJ%201753(%E6%9E%9A%E4%B8%BE).py)
* 使用递归从反转0个棋子到1,2,...,16个逐步查找，如果可以达到目标状态则立刻返回步数。
* 使用 int 表示状态
* 最多 2^16 状态，因此可以使用枚举法
* 使用 [BFS](https://github.com/HzhElena/OJ/blob/master/POJ%202965(BFS).py) pre 指针记录路径会导致超时
#### 1. [2965 The Pilots Brothers' refrigerator](http://poj.org/problem?id=2965) / [Solution](https://github.com/HzhElena/OJ/blob/master/POJ%202965(%E6%9E%9A%E4%B8%BE).py)
> 一个冰箱有4*4矩阵排列的一共16个把手(handles)，每个把手只有'+'(关)和'-'(开)两种状态，当且仅当开关全部为'-',也即冰箱把手都为开启状态的时候冰箱才能被打开。搬动冰箱把手定义一种翻转，即：每次随机选取一个把手翻动，则其所在行和所在列的一共7个把手全部翻转。现在给出16个把手的初始状态（至少有一个把手为'+'），求至少翻动多少轮次，才能够把冰箱门打开，也即把手状态全部为'-'。
输出：达到冰箱开启，即全部把手状态为'-'的最小轮次。首行输出轮次，以下每行输出按次翻动的把手的行号和列号（之间用随意多个空格隔开即可）。

* 使用递归从反转0个门把手到1,2,...,16个逐步查找，如果可以达到目标状态则立刻返回步数。
* 使用 int 表示状态
* 最多 2^16 状态，因此可以使用枚举法。使用枚举法记录转动的把手行号和列号更加方便。
### 构造法
#### 1. [3239 Solution to the n Queens Puzzle](http://poj.org/problem?id=3239) / [Solution](https://github.com/HzhElena/OJ/blob/master/POJ%203239(%E6%9E%84%E9%80%A0).cpp)
由于n数值很大，不可以用回溯法。回溯法至多可以解决 n = 25 的问题。

一、当n mod 6 != 2 或 n mod 6 != 3时：
* (A1):[2,4,6,8,...,m], [1,3,5,7,...,m-1]            (m为偶) 
* (A2):[2,4,6,8,...,m-1], [1,3,5,7,...,m-2], [m]     (m为奇)

二、当n mod 6 == 2 或 n mod 6 == 3时
(当n为偶数,k=n/2；当n为奇数,k=(n-1)/2)

* (B1):[n,n+2,n+4,...,m], [2,4,...,n-2], [n+3,n+5,...,m-1], [1,3,5,...,n+1]        (m为偶,n为偶) 
* (B2):[n,n+2,n+4,...,m-1], [1,3,5,...,n-2], [n+3,...,m], [2,4,...,n+1]            (m为偶,n为奇) 
* (B3):[n,n+2,n+4,...,m-1], [2,4,...,n-2], [n+3,n+5,...,m-2], [1,3,5,...,n+1], [m] (m为奇,n为偶) 
* (B4):[n,n+2,n+4,...,m-2], [1,3,5,...,n-2], [n+3,...,m-1], [2,4,...,n+1], [m]     (m为奇,n为奇) 

(上面有六条序列。一行一个序列，中括号是我额外加上的，方便大家辨认子序列，子序列与子序列之间是连续关系，无视中括号就可以了。第i个数为ai，表示在第i行ai列放一个皇后；... 省略的序列中，相邻两数以2递增。)

### 贪心
#### 1. [1328 Radar Installation](http://poj.org/problem?id=1328) / [Solution](https://github.com/HzhElena/OJ/blob/master/POJ%201328(%E8%B4%AA%E5%BF%83).py)
* 错误的做法：考虑最左边的一个岛屿A，要用一个雷达去覆盖它，又要使得之后的岛屿会尽可能的都在这个雷达的范围里，那么雷达在覆盖A的条件下越往左放置越好，即A刚好在雷达扫描的边界上为最优，我们可以以此来求出雷达的坐标，然后判断继A之后有哪些岛屿在刚刚放置的雷达范围之中，若在便从队列中除去，若不在便以此岛屿再次执行与A一样的操作（即找下一个雷达的布置位置）。 后来发现这种做法是错误的，在放置第一个雷达时，在满足覆盖A的同时，并不是越往右放置越好，因为当雷达往右挪动时，会将不再覆盖左侧的一部分（如图阴影部分），此时B点将需要另外添加一个雷达来覆盖，故这种思路是错误的！
* 将所有的岛屿对应的这段区间记录下来，然后以区间左界从小到大排序就行，之后从第一个区间开始，如果第二个区间与其有交集，就更新这个交集，并从队列中除去区间1，2，如果第三个区间与这个交集又有交集，那么便更新交集并除去区间3直到不满足有交集为止。然后继续模拟这个过程就行了，每模拟以此这个过程ANS++（即区间选点问题）
## Search
### BFS
#### 1. [1753 Flip Game](http://poj.org/problem?id=1753) / [Solution](https://github.com/HzhElena/OJ/blob/master/POJ%201753(BFS).py)
    > 有一4x4棋盘，上面有16枚双面棋子（一面为黑，一面为白）， 
     当翻动一只棋子时，该棋子上下左右相邻的棋子也会同时翻面。 
     以b代表黑面，w代表白面，给出一个棋盘状态， 
     问从该棋盘状态开始，使棋盘变成全黑或全白，至少需要翻转多少步   
* Bit operation ^= 异或操作符 使得int中某一特定位变为1 或 0。
* Use (step>16) to break loop 否则会无穷地循环下去。 
* BFS 内部每一个状态均翻转16个位。


